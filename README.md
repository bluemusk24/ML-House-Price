# ML-House-Price

ML-House-price-project description:

1.  This project was on predicting the prices of house based on following features: Avg. Area Income, Avg. Area House Age, Avg. Area Number of Rooms, Avg. Area Number of Bedrooms, Area Population, Price, Address.

2.  The instructions on how to execute this project is stated as follows: (a) I downloaded the USA_ Housing dataset from Kaggle (b) I read the dataset on jupyter notebook, cleaned the data, did exploratory data analysis and feature engineering, built and trained models- linear regression and ridge regression for my training and validation datasets to predict the prices of houses. Finally, I chose the model with the lowest root mean squared error for my testimg dataset.

3.  I downloaded my ipynb notebook as a python script on visual studio code, named it train.py, did some editing and created a webservice with flask (predict.py) to predict house prices on an unknown dataset. I ensured the model predicted right.

4.  Because I use windows operating system, I downloaded windows subsystem for linux (WSL) to ensure Linux command work on windows computer. Example of such commands are: gunicorn --bind localhost:8080 predict:app

5.  I created a virtual environment for my model to include all its dependencies with pip install pipenv, pipenv install numpy, scikit-learn==1.0.2 flask inorder to download the Pipfile and Pipfile.lock which contained all dependencies.

6.  From docker python image, I got a python image with tag- python:3.10.12-slim, use this code:docker run -it --rm python:3.10.12-slim to download it while I ensured my docker desktop was up and running, created a docker file to overwrite the downloaded python image-docker build -t project-test ., docker run -it --rm --entrypoint=bash project-test, and finally run it with: docker run -it --rm -p 8080:8080 project-test.

7.  Additionally, I deployed my docker container on AWS elasticbeanstalk using command line interface: pipenv install awsebcli --dev, pipenv shell, eb init --help, eb init -p docker -r us-east-1 house-price, ls -a, less .elasticbeanstalk/config.yml, eb local run --port 8080, eb create house-price-env, and terminated using eb terminate churn-serving-env.

8.  Finally, I ensured to run the docker container with Kubernetes, firstly locally on my Laptop by creating clusters with kind before deploying to AWS Elastic Kubernetes Service. I ensured creation of deployment and service yaml files for this. The processes and codes are : * docker build -t <name of docker-image and tag>, * docker run -it --rm -p 8080:8080 <name of docker-image and tag>, * create a model-deployment.yaml file on vsc, type deployment and select the Kubernetes deployment that pops up, * on the yaml file, replace my app = tf-serving-clothing-model, image = docker image name and tag of model, cpu = 128Mi, memory = 500Mi, replicas = 1 and containerPort = <8080/or any specified port>, * kind load docker-image <specified image name and tag>, * kubectl apply -f model-deployment.yaml, * kubectl get deployment, * kubectl get pod, kubectl describe pod <specified pod-name from kubectl get pod> | less, * kubectl port-forward <specified name of pods> 8080:8080, * python3 predict-test.py, * create a model-service.yaml file on vsc, * type service and select the Kubernetes service that pops up, * on the yaml file, replace my app = same name of model-deployment,yaml, port=80 and targetPort=8080. under spec: write type:LoadBalancer, * kubectl apply -f model-service.yaml, * kubectl get service OR svc, * kubectl port-forward <service/outcome created above> 9696:80, * python3 predict-test.py, * create an eks-config.yaml from eksctl.io under the working directory, * eksctl create cluster -f eks-config.yaml, * aws ecr create-repository --repository-name <house-price-image / or any registry name>, * attach variables to the url from our created ECR, * $(aws ecr get-login --no-include-email), * docker push ${MODEL_REMOTE}, * take the URL of the pushed images from AWS EKS and put them in image section of model deployment configuration with this code echo ${MODEL_REMOTE}, * kubectl get nodes, * docker ps, * kubectl apply -f  model-deployment.yaml, * kubectl apply -f  model-service.yaml, * kubectl get pod, * kubectl get service, * kubectl port-forward service/diabetes-risk-model 9696:80, * python3 predict-test.py in new terminal, * telnet a26f9963717184b76b0255b90cb09805-1892142795.us-east-1.elb.amazonaws.com 80, *  Post the external IP DNS from AWS Load balancer in our predict-test.py file as the new URL, * python3 predict-test.py, * login to AWS, checkout created EKS to view the created cluster, EC2 instances, load Balancer, * eksctl delete cluster --name <cluster name>.

